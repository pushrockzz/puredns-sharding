name: puredns-quick-test

on:
  workflow_dispatch:
    inputs:
      chunk_start:
        description: 'First chunk index this run will process (integer)'
        required: true
        default: '0'
      total_chunks:
        description: 'DEPRECATED: Total chunks is now auto-detected.'
        required: false
        default: '8'
      run_counter:
        description: 'Automatic run counter for recursion (auto-incremented)'
        required: false
        default: '0'
      max_runs:
        description: 'Safety cap: stop after this many runs. If unset, it is auto-calculated to finish all chunks.'
        required: false
        default: '999' # High default acts as "no limit"
      words_per_chunk:
        description: 'Words to generate per chunk (test default = 100)'
        required: false
        default: '100'
      domains_count:
        description: 'How many test domains to generate (default = 10)'
        required: false
        default: '10'

env:
  WORKFLOW_FILE: puredns-quicktest.yml
  MATRIX_SIZE: '4'

jobs:
  prepare:
    name: prepare-wordlists-and-resolvers
    runs-on: ubuntu-latest
    outputs:
      artifact-name: wordlists-artifact
      total-chunks: ${{ steps.create_inputs.outputs.total-chunks }}
      effective-max-runs: ${{ steps.create_inputs.outputs.effective-max-runs }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Ensure directories and create/gather wordlist, domains
        id: create_inputs
        run: |
          ensure_dir() {
            dir="$1"
            if [ -e "$dir" ]; then
              if [ -d "$dir" ]; then
                return 0
              else
                timestamp=$(date +%s)
                mv "$dir" "${dir}.bak.${timestamp}"
                echo "Moved file '$dir' to '${dir}.bak.${timestamp}'"
              fi
            fi
            mkdir -p "$dir"
          }

          ensure_dir domains
          ensure_dir wordlists
          ensure_dir results

          DOMAIN_FILE="domains/domains.txt"
          DOM_COUNT="${{ github.event.inputs.domains_count }}"
          if [ -f "$DOMAIN_FILE" ]; then
            echo "Using existing $DOMAIN_FILE"
          else
            echo "Generating $DOM_COUNT test domains into $DOMAIN_FILE"
            : > "$DOMAIN_FILE"
            i=1
            while [ $i -le "$DOM_COUNT" ]; do
              echo "test${i}.example.com" >> "$DOMAIN_FILE"
              i=$((i + 1))
            done
          fi

          WORDLIST="wordlist.txt"
          if [ -f "$WORDLIST" ]; then
            echo "Using existing $WORDLIST in repo"
          else
            TOTAL_CHUNKS="${{ github.event.inputs.total_chunks }}"
            WORDS_PER_CHUNK="${{ github.event.inputs.words_per_chunk }}"
            TOTAL_WORDS=$(( TOTAL_CHUNKS * WORDS_PER_CHUNK ))
            echo "Generating quick-test wordlist with $TOTAL_WORDS words into $WORDLIST"
            : > "$WORDLIST"
            n=1
            while [ $n -le $TOTAL_WORDS ]; do
              echo "w${n}" >> "$WORDLIST"
              n=$((n + 1))
            done
          fi

          CHUNK_LINES="${{ github.event.inputs.words_per_chunk }}"
          rm -f wordlists/chunk-*.txt || true
          split -l "${CHUNK_LINES}" -d -a 4 --additional-suffix=.txt "$WORDLIST" wordlists/chunk-
          
          RESOLVERS_FILE="resolvers.txt"
          RES_URL="https://raw.githubusercontent.com/and0x00/resolvers.txt/main/resolvers.txt"
          wget -qO "$RESOLVERS_FILE" "$RES_URL" || (echo "Failed to download resolvers; creating minimal fallback" && printf '1.1.1.1\n8.8.8.8\n9.9.9.9\n' > "$RESOLVERS_FILE")

          CHUNK_COUNT=$(ls -1 wordlists/chunk-*.txt | wc -l)
          echo "Discovered ${CHUNK_COUNT} actual chunk files."
          echo "total-chunks=${CHUNK_COUNT}" >> $GITHUB_OUTPUT

          # Auto-calculate the number of runs required and respect user's max_runs as a cap
          MATRIX_SIZE=${{ env.MATRIX_SIZE }}
          CALCULATED_RUNS=$(( (CHUNK_COUNT + MATRIX_SIZE - 1) / MATRIX_SIZE ))
          USER_MAX_RUNS=${{ github.event.inputs.max_runs }}
          EFFECTIVE_MAX_RUNS=$(( CALCULATED_RUNS < USER_MAX_RUNS ? CALCULATED_RUNS : USER_MAX_RUNS ))
          
          echo "Calculated runs needed: ${CALCULATED_RUNS}"
          echo "User-defined max_runs cap: ${USER_MAX_RUNS}"
          echo "Effective max_runs for this job: ${EFFECTIVE_MAX_RUNS}"
          echo "effective-max-runs=${EFFECTIVE_MAX_RUNS}" >> $GITHUB_OUTPUT

      - name: Upload wordlists + resolvers + domains as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wordlists-artifact
          path: |
            wordlists
            resolvers.txt
            domains/domains.txt

  brute:
    name: bruteforce-shard (shard ${{ matrix.shard }})
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        shard: [0,1,2,3]
    steps:
      - name: Checkout repo (no credentials)
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Download pre-split wordlists/artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: .

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Cache Go modules & binaries
        uses: actions/cache@v3
        with:
          path: |
            $HOME/go/pkg/mod
            ~/.cache/go-build
            $HOME/go/bin
          key: ${{ runner.os }}-go-cache-${{ github.ref_name }}
          restore-keys: |
            ${{ runner.os }}-go-cache-

      - name: Install massdns
        run: |
          git clone https://github.com/blechschmidt/massdns.git
          cd massdns
          make
          sudo make install
          cd ..

      - name: Install puredns and utilities
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq ca-certificates curl wget
          go install github.com/d3mondev/puredns/v2@latest
          puredns --help

      - name: Compute local chunk file for this shard
        id: vars
        run: |
          SHARD=${{ matrix.shard }}
          CHUNK_START=${{ github.event.inputs.chunk_start }}
          CHUNK_INDEX=$(( CHUNK_START + SHARD ))
          CHUNK_FILE="wordlists/chunk-$(printf '%04d' "$CHUNK_INDEX").txt"
          if [ ! -f "$CHUNK_FILE" ]; then
            echo "chunk_missing=true" >> $GITHUB_OUTPUT
            echo "chunk_file=$CHUNK_FILE" >> $GITHUB_OUTPUT
            echo "CHUNK FILE MISSING: $CHUNK_FILE" >&2
          else
            echo "chunk_missing=false" >> $GITHUB_OUTPUT
            echo "chunk_file=$CHUNK_FILE" >> $GITHUB_OUTPUT
            echo "Using chunk: $CHUNK_FILE"
          fi

      - name: Run puredns bruteforce for this shard (stdin wordlist)
        if: steps.vars.outputs.chunk_missing == 'false'
        id: run_puredns
        run: |
          if [ -e results ]; then
            if [ ! -d results ]; then
              echo "Path 'results' exists and is not a directory. Moving to results.file.bak.<ts>"
              mv results "results.file.bak.$(date +%s)"
            fi
          fi
          mkdir -p results

          CHUNK_FILE="${{ steps.vars.outputs.chunk_file }}"
          DOMAIN_FILE="domains/domains.txt"
          RESOLVERS="resolvers.txt"
          CHUNK_INDEX=$(( ${{ github.event.inputs.chunk_start }} + ${{ matrix.shard }} ))
          SHARD_OUT="results/shard-${CHUNK_INDEX}.txt"
          : > "$SHARD_OUT"

          while IFS= read -r domain || [ -n "$domain" ]; do
            case "$domain" in
              \#*|"") continue ;;
            esac
            SAN=$(printf '%s' "$domain" | tr '/:@' '_' | tr '.' '_')
            PUREDNS_FILE="results/puredns-${CHUNK_INDEX}-${SAN}.txt"
            WILDCARD_FILE="results/wildcards-${CHUNK_INDEX}-${SAN}.txt"
            MASSDNS_FILE="results/massdns-${CHUNK_INDEX}-${SAN}.txt"
            echo "[shard $CHUNK_INDEX] bruteforcing $domain using $CHUNK_FILE"
            cat "$CHUNK_FILE" | puredns bruteforce "$domain" \
              -r "$RESOLVERS" \
              --rate-limit 5000 \
              --skip-validation \
              --wildcard-tests 300 \
              --wildcard-batch 100000 \
              --write "$PUREDNS_FILE" \
              --write-wildcards "$WILDCARD_FILE" \
              --write-massdns "$MASSDNS_FILE" \
              --quiet
            if [ -s "$PUREDNS_FILE" ]; then
              cat "$PUREDNS_FILE" >> "$SHARD_OUT"
            fi
          done < "$DOMAIN_FILE"
          echo "shard_out=${SHARD_OUT}" >> $GITHUB_OUTPUT

      - name: (Optional) Commit results back to repo if PAT_TOKEN present
        if: env.PAT_TOKEN != ''
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          CHUNK_START=${{ github.event.inputs.chunk_start }}
          SHARD=${{ matrix.shard }}
          CHUNK_INDEX=$(( CHUNK_START + SHARD ))
          OUTFILE="results/shard-${CHUNK_INDEX}.txt"

          if [ ! -s "$OUTFILE" ]; then
            echo "No new results in $OUTFILE to commit."
            exit 0
          fi

          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git remote set-url origin "https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}"
          git add "$OUTFILE"
          
          if git diff --staged --quiet; then
            echo "No new results to commit for $OUTFILE"
          else
            git commit -m "Add quick-test puredns results: shard ${CHUNK_INDEX}"
            for try in 1 2 3; do
              if git pull --rebase --autostash origin ${{ github.ref_name }}; then
                if git push origin HEAD:${{ github.ref_name }}; then
                  echo "Pushed results for $OUTFILE"
                  break 2
                fi
              fi
              echo "Push attempt $try failed; retrying..."
              sleep $((try * 2))
            done
          fi

  dispatch-next:
    name: dispatch-next-run
    runs-on: ubuntu-latest
    needs: [prepare, brute]
    if: always()
    env:
      PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
      GITHUB_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - name: Compute and dispatch next run
        run: |
          if [ -z "${PAT_TOKEN}" ]; then
            echo "Error: secrets.PAT_TOKEN is required to dispatch the next workflow run." >&2
            exit 1
          fi

          CHUNK_START=${{ github.event.inputs.chunk_start }}
          TOTAL_CHUNKS=${{ needs.prepare.outputs.total-chunks }}
          RUN_COUNTER=${{ github.event.inputs.run_counter }}
          MAX_RUNS=${{ needs.prepare.outputs.effective-max-runs }} # Use effective max_runs from prepare job
          
          MATRIX_SIZE=${{ env.MATRIX_SIZE }}
          NEXT_START=$((CHUNK_START + MATRIX_SIZE))
          NEXT_COUNTER=$((RUN_COUNTER + 1))

          echo "Current start: ${CHUNK_START}, Matrix size: ${MATRIX_SIZE}, Next start: ${NEXT_START}, Total chunks: ${TOTAL_CHUNKS}, Run counter: ${RUN_COUNTER}, Effective max runs: ${MAX_RUNS}"

          if [ "$NEXT_START" -ge "$TOTAL_CHUNKS" ]; then
            echo "All chunks processed. Terminating recursion."
            exit 0
          fi

          # NOTE: The check is now against the *total* number of runs, not the counter increment.
          # We check if the *current* run counter has already met or exceeded the max.
          if [ "${NEXT_COUNTER}" -ge "${MAX_RUNS}" ]; then
            echo "Next run (${NEXT_COUNTER}) would exceed the effective max_runs limit (${MAX_RUNS}). Terminating recursion."
            exit 0
          fi

          URL="https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ env.WORKFLOW_FILE }}/dispatches"
          BODY=$(printf '{"ref":"%s","inputs":{"chunk_start":"%s","total_chunks":"%s","run_counter":"%s","max_runs":"%s","words_per_chunk":"%s","domains_count":"%s"}}' \
            "${{ github.ref_name }}" \
            "${NEXT_START}" \
            "${TOTAL_CHUNKS}" \
            "${NEXT_COUNTER}" \
            "${MAX_RUNS}" \
            "${{ github.event.inputs.words_per_chunk }}" \
            "${{ github.event.inputs.domains_count }}")

          echo "Dispatching next run to ${URL}"
          for i in 1 2 3 4; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${PAT_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d "$BODY" \
              "$URL")
            
            if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
              echo "Dispatch succeeded (HTTP ${HTTP_STATUS})"
              exit 0
            fi
            echo "Dispatch attempt ${i} failed (HTTP ${HTTP_STATUS}). Retrying in $((i*2)) seconds..."
            sleep $((i * 2))
          done

          echo "Failed to dispatch next run after multiple retries. Terminating with an error."
          exit 0
